/*
 * @lc app=leetcode.cn id=70 lang=cpp
 *
 * [70] 爬楼梯
 */
#include <cmath>
#include <vector>
using namespace std;
// @lc code=start
class Solution {
public:
  int climbStairs(int n) {
    // 斐波那契数列问题
    // 第一个想到的是简单动态规划，使用滚动数组的方法，方法数量的转移方程很好给出:
    // f(x) = f(x-1) + f(x-2)，第一步先走1步或者两步
    // int p = 0;
    // int q = 0;
    // int r = 1;
    // for (int i = 0; i < n; ++i) {
    //   p = q;
    //   q = r;
    //   r = p + q;
    // }
    // return r;
    // 上述算法O(n)时间复杂度。
    // 通项公式法
    // 解法步骤

    // 写出递归关系 确定递归关系的形式和阶数。例如，T(n) = 5T(n-1) - 6T(n-2)
    // 是一个二阶线性齐次递归关系。

    // 假设特征解形式 假设解为 T(n) = rⁿ，其中 r 是待定的常数。

    // 建立特征方程 将假设的解代入递归关系，得到关于 r 的特征方程。例如，对于
    // T(n) = 5T(n-1) - 6T(n-2)，特征方程为 r² - 5r + 6 = 0。

    // 求解特征方程 解出特征方程的所有根。例如，上述方程的根为 r₁ = 2 和 r₂ =
    // 3。

    // 写出通解 根据特征根的情况： 若特征根互异，通解为 T(n) = C₁r₁ⁿ + C₂r₂ⁿ。
    // 若有重根，通解为 T(n) = (C₁ + C₂n)rⁿ。 若有复根，通解为 T(n) = Aαⁿcos(nβ)
    // + Bαⁿsin(nβ)。

    // 利用初始条件求常数 代入初始条件（如 T(0), T(1), ...），解出常数 C₁, C₂
    // 等。
    //  特征方程x² = x +1 ，特征根是 x1=(1-√5)/2，x2=(1+√5)/2
    // f(1) =c1*(1-√5)/2 + c2*(1+√5)/2 = 1; f(2) =c1*((1-√5)/2)² +
    // C2*((1+√5)/2)²
    double sqrt5 = sqrt(5);
    // 斐波那契数列对齐，f(n)对应斐波那契数列第n+1项，题目中的n从斐波那契数列的第三项开始，故公式会落后1项
    return (int)round(
        (pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1)) / sqrt5);
  }
};
// @lc code=end
